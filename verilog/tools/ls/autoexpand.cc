// Copyright 2023 The Verible Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "verilog/tools/ls/autoexpand.h"

#include <algorithm>
#include <cstdint>
#include <regex>

#include "absl/container/flat_hash_map.h"
#include "absl/container/flat_hash_set.h"
#include "absl/container/node_hash_map.h"
#include "common/text/text_structure.h"
#include "verilog/CST/declaration.h"
#include "verilog/CST/dimensions.h"
#include "verilog/CST/expression.h"
#include "verilog/CST/identifier.h"
#include "verilog/CST/module.h"
#include "verilog/CST/net.h"
#include "verilog/CST/port.h"
#include "verilog/CST/type.h"
#include "verilog/CST/verilog_matchers.h"  // IWYU pragma: keep
#include "verilog/formatting/format_style_init.h"
#include "verilog/formatting/formatter.h"

namespace verilog {
using verible::LineColumn;
using verible::LineColumnRange;
using verible::StringSpanOfSymbol;
using verible::Symbol;
using verible::SymbolCastToNode;
using verible::SymbolKind;
using verible::SymbolPtr;
using verible::SyntaxTreeLeaf;
using verible::SyntaxTreeNode;
using verible::TextStructureView;
using verible::TokenInfo;
using verible::lsp::CodeAction;
using verible::lsp::CodeActionParams;
using verible::lsp::TextEdit;
using verilog::formatter::FormatStyle;
using verilog::formatter::InitializeFromFlags;

namespace {

// Takes a TextStructureView and generates LSP TextEdits for AUTO expansion
class AutoExpander {
 public:
  // Represents a port connection
  struct Connection {
    absl::string_view port_name;  // The name of the port in the module instance
    bool emit_dimensions;  // If true, when emitted, the connection should be
                           // annotated with the signal dimensions
  };

  // Stores information about the instance the port is connected to
  struct ConnectedInstance {
    absl::string_view instance;  // Name of the instance a port is connected to
    absl::string_view type;      // Type of the instance a port is connected to
  };

  // Simple representation of a port
  struct Port {
    enum class Direction { kInput, kInout, kOutput };
    enum class Declaration { kUndeclared, kAutogenerated, kDeclared };

    Direction direction;      // Direction of the port
    Declaration declaration;  // Is it user-declared or autogenerated
    absl::string_view name;   // Name of the port
    size_t offset;            // Byte offset of the port's declaration (relative
                              // to the module span)
    std::optional<ConnectedInstance> conn_inst;  // (Optional) What instance is
                                                 // it connected to?
    std::vector<absl::string_view> packed_dimensions;    // Spans of this port's
                                                         // packed dimensions
    std::vector<absl::string_view> unpacked_dimensions;  // Spans of this port's
                                                         // unpacked dimensions

    // Writes the port's direction to the output stream
    void EmitDirection(std::ostream &output) const;

    // Writes the port's identifier with packed and unpacked dimensions to the
    // output stream
    void EmitIdWithDimensions(std::ostream &output) const;

    // Writes a comment describing the port's connection to the output stream
    void EmitConnectionComment(std::ostream &output) const;

    // Returns true if the port is connected to any instance
    bool IsConnected() const { return conn_inst.has_value(); }
  };

  // Represents an AUTO_TEMPLATE
  struct Template {
    using Map = absl::flat_hash_map<absl::string_view, std::vector<Template>>;

    int64_t offset;  // Offset of the template in the source file
    absl::flat_hash_map<absl::string_view, Connection>
        connections;  // Map of instance ports ports to connected module ports
  };

  enum class PortDeclStyle {
    kColonSeparator,
    kCommaSeparator,
    kCommaSeparatorExceptLast
  };

  // Module information relevant to AUTO expansion
  class Module {
   public:
    explicit Module(const Symbol &module)
        : symbol_(module), name_(GetModuleName(symbol_)->get().text()) {
      RetrieveModuleHeaderPorts();
      RetrieveModuleBodyPorts();
    }

    // Writes all port names that match the predicate to the output stream,
    // under the specified heading comment
    void EmitNonAnsiPortList(
        std::ostream &output, absl::string_view indent,
        absl::string_view heading,
        const std::function<bool(const Port &)> &pred) const;

    // Writes port connections to all ports to the output stream, under the
    // specified heading comment
    void EmitPortConnections(std::ostream &output, absl::string_view indent,
                             absl::string_view header,
                             const std::function<bool(const Port &)> &pred,
                             const Template *tmpl) const;

    // Writes declarations of ports that fulfill the given predicate to the
    // output stream
    void EmitPortDeclarations(
        std::ostream &output, absl::string_view indent, PortDeclStyle style,
        const std::function<bool(const Port &)> &pred) const;

    // Writes wire declarations of undeclared output ports to the output stream,
    // with the provided span defining which existing wires were autogenerated
    void EmitUndeclaredOutputWireDeclarations(
        std::ostream &output, absl::string_view indent,
        absl::string_view auto_span) const;

    // Writes reg declarations of unconnected output ports to the output stream,
    // with the provided span defining which existing regs were autogenerated
    void EmitUnconnectedOutputRegDeclarations(
        std::ostream &output, absl::string_view indent,
        absl::string_view auto_span) const;

    // Calls the closure on each port and the name of the port that should be
    // connected to it. If a template is given, the connected port name is taken
    // from the template, otherwise it's the same as the port name.
    void GenerateConnections(
        const Template *tmpl,
        const std::function<void(const Port &, const Connection &)> &fun) const;

    // Set an existing port's connection, or create a new port with the given
    // name, direction, and connection
    void AddGeneratedConnection(
        absl::string_view port_name, Port::Direction direction,
        const ConnectedInstance &connection,
        const std::vector<absl::string_view> &packed_dimensions,
        const std::vector<absl::string_view> &unpacked_dimensions);

    // Erase all ports that were declared within the given byte range
    void ErasePortsInRange(size_t start_offset, size_t length);

    // Marks each port matching the predicate as autogenerated
    void MarkUndeclaredPortsAsAutogenerated(Port::Direction direction);
    // Sets the offset of each port matching the predicate
    void SetUndeclaredPortOffsets(Port::Direction direction, size_t offset);

    // Sort ports by byte offset (relative to the module span)
    void SortPortsByOffset();

    // Gets all AUTO_TEMPLATEs from the module
    void RetrieveAutoTemplates();

    // Gets all dependencies of the module (modules instantiated within it)
    void RetrieveDependencies(
        const absl::node_hash_map<absl::string_view, Module> &modules);

    // Retrieves the matching template from a typename -> template map
    const Template *GetAutoTemplate(absl::string_view type_id,
                                    int64_t instance_offset) const;

    // Returns true if the module depends on (uses) a given module
    bool DependsOn(const Module *module) const {
      absl::flat_hash_set<const Module *> visited;
      return DependsOn(module, &visited);
    }

    bool AnyPorts(const std::function<bool(const Port &)> &pred) {
      return std::find_if(ports_.begin(), ports_.end(), pred) != ports_.end();
    }

    // Returns the Symbol representing this module
    const verible::Symbol &Symbol() const { return symbol_; }

    // Returns the module name
    absl::string_view Name() const { return name_; }

   private:
    //  Gets ports from the header of the module
    void RetrieveModuleHeaderPorts();

    // Gets ports from the body of the module
    void RetrieveModuleBodyPorts();

    // Store the given port in the internal vector
    void PutDeclaredPort(const SyntaxTreeNode &port_node);

    // Recurses into dependencies to check if we depend on a given module.
    // Stores visited modules in a set to avoid infinite loops. For big
    // dependency graphs one should build a proper graph and do a
    // topological sort. However, these dependencies (and the dependent) are all
    // from a single file, and usually there is only one module per file. This
    // should be fast enough for unusual cases where there are multiple modules
    // in a single file.
    bool DependsOn(const Module *module,
                   absl::flat_hash_set<const Module *> *visited) const;

    // The symbol that represents this module
    const verible::Symbol &symbol_;

    // The name of this module
    const absl::string_view name_;

    // This module's ports
    std::vector<Port> ports_;

    // This module's direct dependencies
    absl::flat_hash_set<const Module *> dependencies_;

    // This module's AUTO_TEMPLATEs
    Template::Map templates_;
  };

  AutoExpander(const TextStructureView &text_structure,
               SymbolTableHandler *symbol_table_handler)
      : text_structure_(text_structure),
        symbol_table_handler(symbol_table_handler) {
    // Get the indentation from the format style
    // TODO: Add a test that formats the file after AUTO expansion and checks
    // that the output is the same
    FormatStyle format_style;
    InitializeFromFlags(&format_style);
    indent_ = std::string(format_style.indentation_spaces, ' ');
  }

  // Retrieves port names from a module declared before the given offset
  absl::flat_hash_set<absl::string_view> GetPortsListedBefore(
      const Symbol &module, LineColumn linecol) const;

  // Retrieves port names from a module instance connected before the given
  // offset
  absl::flat_hash_set<absl::string_view> GetPortsConnectedBefore(
      const Symbol &instance, LineColumn linecol) const;

  // Expands AUTOARG for the given module
  std::optional<TextEdit> ExpandAutoarg(const Module &module) const;

  // Expands AUTOINST for the given module instance
  std::optional<TextEdit> ExpandAutoinst(Module *module, const Symbol &instance,
                                         absl::string_view type_id,
                                         const Template *tmpl);

  // Expands AUTO<port-direction/data-type> for the given module
  // Limitation: this only detects ports from AUTOINST. This limitation is also
  // present in the original Emacs Verilog-mode.
  std::optional<TextEdit> ExpandAutoDeclarations(
      const Module &module, const std::cmatch &match, absl::string_view indent,
      absl::string_view description,
      const std::function<void(const Module &, std::ostream &)> &emit) const;

  // Expands AUTOINPUT/AUTOINOUT/AUTOOUTPUT for the given module
  std::optional<TextEdit> ExpandAutoPorts(
      Module *module, const std::optional<std::cmatch> &match,
      Port::Direction direction) const;

  // Expands AUTOWIRE for the given module
  std::optional<TextEdit> ExpandAutowire(const Module &module) const;

  // Expands AUTOREG for the given module
  std::optional<TextEdit> ExpandAutoreg(const Module &module) const;

  // Expands all AUTOs in the buffer
  std::vector<TextEdit> Expand();

 private:
  // Text structure of the buffer to expand AUTOs in
  const TextStructureView &text_structure_;

  // Symbol table wrapper for the language server
  SymbolTableHandler *symbol_table_handler;

  // String to add at the end of each generated line
  std::string indent_;

  // Gathered module information (module name -> module info)
  absl::node_hash_map<absl::string_view, Module> modules_;

  // Regex for finding AUTOARG comments
  static const std::regex autoarg_re_;

  // Regex for finding AUTOINST comments
  static const std::regex autoinst_re_;

  // Regexes for AUTO_TEMPLATE comments
  static const std::regex autotemplate_detect_re_;
  static const std::regex autotemplate_type_re_;
  static const std::regex autotemplate_conn_re_;

  // Regexes for AUTOINPUT/AUTOOUTPUT/AUTOINOUT/AUTOWIRE/AUTOREG comments
  static const std::regex autoinput_re_;
  static const std::regex autooutput_re_;
  static const std::regex autoinout_re_;
  static const std::regex autowire_re_;
  static const std::regex autoreg_re_;
};

const std::regex AutoExpander::autoarg_re_{R"(/\*\s*AUTOARG\s*\*/)"};

const std::regex AutoExpander::autoinst_re_{R"(/\*\s*AUTOINST\s*\*/)"};

// AUTO_TEMPLATE regex breakdown:
// /\*                             – start of comment
// (\s*\S+\s+AUTO_TEMPLATE\s*\n)*  – optional other AUTO_TEMPLATE types, end
//                                   with newline
// \s*\S+\s+AUTO_TEMPLATE          – at least one AUTO_TEMPLATE is required
// \s*(".*")?                      – optional instance name regex
// \s*\([\s\S]*?\);                – parens with port connections
// \s*\*/                          – end of comment
const std::regex AutoExpander::autotemplate_detect_re_{
    R"(/\*(\s*\S+\s+AUTO_TEMPLATE\s*\n)*\s*\S+\s+AUTO_TEMPLATE\s*(".*")?\s*\([\s\S]*?\);\s*\*/)"};

// AUTO_TEMPLATE type regex: the first capturing group is the instance type
const std::regex AutoExpander::autotemplate_type_re_{
    R"((\S+)\s+AUTO_TEMPLATE)"};

// AUTO_TEMPLATE connection regex breakdown:
// \.\s*      – starts with a dot
// ([^\s(]+?) – first group, at least one character other than whitespace or
//              opening paren
// \s*\(\s*   – optional whitespace, opening paren, optional whitespace again
// ([^\s(]+?) – second group, same as the first one
// \s*(\[\])? – optional third group, capturing '[]'
// \s*\)*     – optional whitespace, closing paren
const std::regex AutoExpander::autotemplate_conn_re_{
    R"(\.\s*([^\s(]+?)\s*\(\s*([^\s(]+?)\s*(\[\])?\s*\))"};

// AUTOINPUT/OUTPUT/INOUT/WIRE/REG regex breakdown:
// (/\*\s* ... \s*\*/\s*?\n)            – starting comment
// (?:\s*//.*\n)?                       – optional starting comment
//                                        ("Beginning of automatic...")
// (?: ... )?                           – an optional non-capturing group:
//   [\s\S]*?                           – any text (usually port
//                                        declarations)
//   [^\S\r\n]*// End of automatics.*\n – ended by an "End of automatics"
//                                        comment
#define MAKE_AUTODECL_REGEX(decl_kind) \
  R"((/\*\s*AUTO)" decl_kind           \
  R"(\s*\*/\s*?\n)(?:\s*//.*\n)?(?:[\s\S]*?[^\S\r\n]*// End of automatics.*\n)?)"
const std::regex AutoExpander::autoinput_re_{MAKE_AUTODECL_REGEX("INPUT")};
const std::regex AutoExpander::autoinout_re_{MAKE_AUTODECL_REGEX("INOUT")};
const std::regex AutoExpander::autooutput_re_{MAKE_AUTODECL_REGEX("OUTPUT")};
const std::regex AutoExpander::autowire_re_{MAKE_AUTODECL_REGEX("WIRE")};
const std::regex AutoExpander::autoreg_re_{MAKE_AUTODECL_REGEX("REG")};

void AutoExpander::Port::EmitDirection(std::ostream &output) const {
  switch (direction) {
    case Port::Direction::kInput:
      output << "input ";
      break;
    case Port::Direction::kInout:
      output << "inout ";
      break;
    case Port::Direction::kOutput:
      output << "output ";
      break;
    default:
      LOG(ERROR) << "Incorrect port direction";
      break;
  }
}

void AutoExpander::Port::EmitIdWithDimensions(std::ostream &output) const {
  if (!packed_dimensions.empty()) {
    for (const absl::string_view dimension : packed_dimensions) {
      output << dimension;
    }
    output << ' ';
  }
  output << name;
  for (const absl::string_view dimension : unpacked_dimensions) {
    output << dimension;
  }
}

void AutoExpander::Port::EmitConnectionComment(std::ostream &output) const {
  if (!conn_inst) return;
  switch (direction) {
    case Direction::kInput:
      output << "  // To " << conn_inst->instance << " of " << conn_inst->type;
      break;
    case Direction::kInout:
      output << "  // To/From " << conn_inst->instance << " of "
             << conn_inst->type;
      break;
    case Direction::kOutput:
      output << "  // From " << conn_inst->instance << " of "
             << conn_inst->type;
      break;
    default:
      LOG(ERROR) << "Incorrect port direction";
      break;
  }
}

void AutoExpander::Module::EmitNonAnsiPortList(
    std::ostream &output, const absl::string_view indent,
    const absl::string_view heading,
    const std::function<bool(const Port &)> &pred) const {
  bool first = true;
  for (const Port &port : ports_) {
    if (!pred(port)) continue;
    if (first) {
      if (output.tellp() != 0) output << ',';
      output << '\n' << indent << "// " << heading << '\n' << indent;
      first = false;
    } else {
      output << ", ";
    }
    output << port.name;
  }
}

void AutoExpander::Module::EmitPortConnections(
    std::ostream &output, const absl::string_view indent,
    const absl::string_view header,
    const std::function<bool(const Port &)> &pred, const Template *tmpl) const {
  bool first = true;
  GenerateConnections(tmpl, [&](const Port &port, const Connection &connected) {
    if (!pred(port)) return;
    if (first) {
      if (output.tellp() != 0) output << ',';
      output << '\n' << indent << "// " << header;
      first = false;
    } else {
      output << ',';
    }
    output << '\n' << indent << '.' << port.name << '(' << connected.port_name;
    if (!connected.emit_dimensions) {
      output << ')';
      return;
    }
    if (port.packed_dimensions.size() > 1 ||
        !port.unpacked_dimensions.empty()) {
      output << "/*";
      for (const absl::string_view dimension : port.packed_dimensions) {
        output << dimension;
      }
      if (!port.unpacked_dimensions.empty()) {
        output << '.';
        for (const absl::string_view dimension : port.unpacked_dimensions) {
          output << dimension;
        }
      }
      output << "*/";
    } else if (port.packed_dimensions.size() == 1) {
      output << port.packed_dimensions[0];
    }
    output << ')';
  });
}

// Checks if two string spans are overlapping
bool SpansOverlapping(const absl::string_view first,
                      const absl::string_view second) {
  return first.end() > second.begin() && first.begin() < second.end();
}

void AutoExpander::Module::EmitUndeclaredOutputWireDeclarations(
    std::ostream &output, const absl::string_view indent,
    const absl::string_view auto_span) const {
  absl::flat_hash_set<absl::string_view> declared_wires;
  for (const auto &reg : FindAllNetVariables(symbol_)) {
    const SyntaxTreeLeaf *const net_name_leaf =
        GetNameLeafOfNetVariable(*reg.match);
    const absl::string_view net_name = net_name_leaf->get().text();
    if (!SpansOverlapping(net_name, auto_span)) {
      declared_wires.insert(net_name);
    }
  }

  for (const Port &port : ports_) {
    if (port.direction != Port::Direction::kInput &&
        port.declaration == Port::Declaration::kUndeclared &&
        port.IsConnected() && !declared_wires.contains(port.name)) {
      output << indent << "wire ";
      port.EmitIdWithDimensions(output);
      output << ';';
      port.EmitConnectionComment(output);
      output << '\n';
    }
  }
}

void AutoExpander::Module::EmitUnconnectedOutputRegDeclarations(
    std::ostream &output, const absl::string_view indent,
    const absl::string_view auto_span) const {
  absl::flat_hash_set<absl::string_view> declared_regs;
  for (const auto &reg : FindAllRegisterVariables(symbol_)) {
    const SyntaxTreeLeaf *const reg_name_leaf =
        GetNameLeafOfRegisterVariable(*reg.match);
    const absl::string_view reg_name = reg_name_leaf->get().text();
    if (!SpansOverlapping(reg_name, auto_span)) {
      declared_regs.insert(reg_name);
    }
  }

  for (const Port &port : ports_) {
    if (port.direction == Port::Direction::kOutput &&
        port.declaration == Port::Declaration::kDeclared &&
        !port.IsConnected() && !declared_regs.contains(port.name)) {
      output << indent << "reg ";
      port.EmitIdWithDimensions(output);
      output << ";\n";
    }
  }
}

void AutoExpander::Module::GenerateConnections(
    const Template *tmpl,
    const std::function<void(const Port &, const Connection &)> &fun) const {
  for (const Port &port : ports_) {
    Connection connected{.port_name = port.name, .emit_dimensions = true};
    if (tmpl) {
      const auto it = tmpl->connections.find(port.name);
      if (it != tmpl->connections.end()) connected = it->second;
    }
    fun(port, connected);
  }
}

void AutoExpander::Module::AddGeneratedConnection(
    const absl::string_view port_name, const Port::Direction direction,
    const ConnectedInstance &connection,
    const std::vector<absl::string_view> &packed_dimensions,
    const std::vector<absl::string_view> &unpacked_dimensions) {
  for (Port &port : ports_) {
    if (port.name == port_name) {
      port.conn_inst = connection;
      return;
    }
  }
  ports_.push_back({direction, Port::Declaration::kUndeclared, port_name, 0,
                    connection, packed_dimensions, unpacked_dimensions});
}

void AutoExpander::Module::ErasePortsInRange(const size_t start_offset,
                                             const size_t length) {
  const size_t end_offset = start_offset + length;
  const auto it =
      std::remove_if(ports_.begin(), ports_.end(), [=](const Port &port) {
        return port.offset >= start_offset && port.offset < end_offset;
      });
  ports_.erase(it, ports_.end());
}

void AutoExpander::Module::MarkUndeclaredPortsAsAutogenerated(
    const Port::Direction direction) {
  for (Port &port : ports_) {
    if (port.declaration == Port::Declaration::kUndeclared &&
        port.direction == direction) {
      port.declaration = Port::Declaration::kAutogenerated;
    }
  }
}

void AutoExpander::Module::SetUndeclaredPortOffsets(
    const Port::Direction direction, size_t offset) {
  for (Port &port : ports_) {
    if (port.declaration == Port::Declaration::kUndeclared &&
        port.direction == direction) {
      port.offset = offset;
    }
  }
}

void AutoExpander::Module::SortPortsByOffset() {
  // Stable sort is needed here, as ports autogenerated via AUTOINPUT,
  // AUTOOUTPUT, and AUTOINOUT get assigned one offset, which is the start of
  // the corresponding `AUTO` comment. Using unstable sort results in a random
  // order of ports.
  std::stable_sort(ports_.begin(), ports_.end(),
                   [](const Port &left, const Port &right) {
                     return left.offset < right.offset;
                   });
}

void AutoExpander::Module::RetrieveAutoTemplates() {
  const absl::string_view module_span = StringSpanOfSymbol(symbol_);
  std::cmatch autotemplate_match;
  auto autotemplate_begin = module_span.begin();
  while (std::regex_search(autotemplate_begin, module_span.end(),
                           autotemplate_match, autotemplate_detect_re_)) {
    autotemplate_begin += autotemplate_match.position();
    // The begin:end range will be searched for module types and connections
    auto begin = autotemplate_begin;
    const auto end = begin + autotemplate_match.length();
    Template tmpl{.offset = std::distance(module_span.begin(), begin)};
    std::cmatch match;

    while (std::regex_search(begin, end, match, autotemplate_conn_re_)) {
      const absl::string_view instance_port_id{
          begin + match.position(1), static_cast<size_t>(match.length(1))};
      const absl::string_view module_port_id{
          begin + match.position(2), static_cast<size_t>(match.length(2))};
      tmpl.connections.insert(
          std::make_pair(instance_port_id,
                         Connection{.port_name = module_port_id,
                                    .emit_dimensions = match.length(3) != 0}));
      begin += match.position() + match.length();
    }

    begin = autotemplate_begin;
    while (std::regex_search(begin, end, match, autotemplate_type_re_)) {
      const absl::string_view type_id{begin + match.position(1),
                                      static_cast<size_t>(match.length(1))};
      templates_[type_id].push_back(tmpl);
      begin += match.position() + match.length();
    }

    autotemplate_begin = end;
  }
}

void AutoExpander::Module::RetrieveDependencies(
    const absl::node_hash_map<absl::string_view, Module> &modules) {
  for (const auto &data : FindAllDataDeclarations(symbol_)) {
    const verible::Symbol *const type_id_node =
        GetTypeIdentifierFromDataDeclaration(*data.match);
    // Some data declarations do not have a type id, ignore those
    if (!type_id_node) continue;
    const absl::string_view dependency_name = StringSpanOfSymbol(*type_id_node);
    const auto it = modules.find(dependency_name);
    if (it != modules.end()) {
      dependencies_.insert(&it->second);
    }
  }
}

const AutoExpander::Template *AutoExpander::Module::GetAutoTemplate(
    const absl::string_view type_id, const int64_t instance_offset) const {
  const auto it = templates_.find(type_id);
  if (it == templates_.end()) return nullptr;
  const Template *matching_tmpl = nullptr;
  // Linear search for the matching template (there should be very few
  // templates per type, often just one)
  for (const Template &tmpl : it->second) {
    if (instance_offset < tmpl.offset) break;
    matching_tmpl = &tmpl;
  }
  return matching_tmpl;
}

void AutoExpander::Module::EmitPortDeclarations(
    std::ostream &output, const absl::string_view indent,
    const PortDeclStyle style,
    const std::function<bool(const Port &)> &pred) const {
  const auto end = std::find_if(ports_.crbegin(), ports_.crend(), pred).base();
  for (auto it = ports_.cbegin(); it != end; it++) {
    const Port &port = *it;
    if (!pred(port)) continue;
    output << indent;
    port.EmitDirection(output);
    port.EmitIdWithDimensions(output);
    if (style == PortDeclStyle::kColonSeparator) {
      output << ';';
    } else if (style == PortDeclStyle::kCommaSeparator || it + 1 < end) {
      output << ',';
    }
    port.EmitConnectionComment(output);
    output << '\n';
  }
}

void AutoExpander::Module::RetrieveModuleHeaderPorts() {
  const auto module_ports = GetModulePortDeclarationList(symbol_);
  if (!module_ports) return;
  for (const SymbolPtr &port : module_ports->children()) {
    if (port->Kind() == SymbolKind::kLeaf) continue;
    const SyntaxTreeNode &port_node = SymbolCastToNode(*port);
    const NodeEnum tag = NodeEnum(port_node.Tag().tag);
    if (tag == NodeEnum::kPortDeclaration) {
      PutDeclaredPort(port_node);
    }
  }
}

void AutoExpander::Module::RetrieveModuleBodyPorts() {
  for (const auto &port : FindAllModulePortDeclarations(symbol_)) {
    PutDeclaredPort(SymbolCastToNode(*port.match));
  }
}

void AutoExpander::Module::PutDeclaredPort(const SyntaxTreeNode &port_node) {
  const NodeEnum tag = NodeEnum(port_node.Tag().tag);
  const SyntaxTreeLeaf *const dir_leaf =
      tag == NodeEnum::kPortDeclaration
          ? GetDirectionFromPortDeclaration(port_node)
          : GetDirectionFromModulePortDeclaration(port_node);
  const SyntaxTreeLeaf *const id_leaf =
      tag == NodeEnum::kPortDeclaration
          ? GetIdentifierFromPortDeclaration(port_node)
          : GetIdentifierFromModulePortDeclaration(port_node);
  if (!dir_leaf || !id_leaf) return;
  const absl::string_view dir_span = dir_leaf->get().text();
  const absl::string_view name = id_leaf->get().text();

  const absl::string_view module_span = StringSpanOfSymbol(symbol_);
  const size_t offset =
      static_cast<size_t>(std::distance(module_span.begin(), dir_span.begin()));

  const auto get_dimension_spans = [](const auto &dimension_nodes) {
    std::vector<absl::string_view> dimension_spans;
    dimension_spans.reserve(dimension_nodes.size());
    for (auto &dimension : dimension_nodes) {
      for (const auto &scalar :
           SearchSyntaxTree(*dimension.match, NodekDimensionScalar())) {
        dimension_spans.push_back(StringSpanOfSymbol(*scalar.match));
      }
      for (const auto &range :
           SearchSyntaxTree(*dimension.match, NodekDimensionRange())) {
        dimension_spans.push_back(StringSpanOfSymbol(*range.match));
      }
    }
    return dimension_spans;
  };
  std::vector<absl::string_view> packed_dimensions =
      get_dimension_spans(FindAllPackedDimensions(port_node));
  std::vector<absl::string_view> unpacked_dimensions =
      get_dimension_spans(FindAllUnpackedDimensions(port_node));

  Port::Direction direction;
  if (dir_span == "input") {
    direction = Port::Direction::kInput;
  } else if (dir_span == "inout") {
    direction = Port::Direction::kInout;
  } else if (dir_span == "output") {
    direction = Port::Direction::kOutput;
  } else {
    LOG(ERROR) << "Incorrect port direction";
    return;
  }

  ports_.push_back({direction,
                    Port::Declaration::kDeclared,
                    name,
                    offset,
                    {},
                    std::move(packed_dimensions),
                    std::move(unpacked_dimensions)});
}

bool AutoExpander::Module::DependsOn(
    const Module *module, absl::flat_hash_set<const Module *> *visited) const {
  visited->insert(this);
  for (const Module *dependency : dependencies_) {
    if (dependency == module) return true;
    if (!visited->contains(dependency)) {
      if (dependency->DependsOn(module, visited)) return true;
    }
  }
  return false;
}

absl::flat_hash_set<absl::string_view> AutoExpander::GetPortsListedBefore(
    const Symbol &module, const LineColumn linecol) const {
  absl::flat_hash_set<absl::string_view> ports_before;
  const auto all_ports = GetModulePortDeclarationList(module);
  if (!all_ports) return {};

  for (const SymbolPtr &port : all_ports->children()) {
    if (port->Kind() == SymbolKind::kLeaf) continue;
    const SyntaxTreeNode &port_node = SymbolCastToNode(*port);
    const NodeEnum tag = NodeEnum(port_node.Tag().tag);
    const SyntaxTreeLeaf *port_id_node = nullptr;

    if (tag == NodeEnum::kPortDeclaration) {
      port_id_node = GetIdentifierFromPortDeclaration(port_node);
    } else if (tag == NodeEnum::kPort) {
      const SyntaxTreeNode *const port_ref_node =
          GetPortReferenceFromPort(port_node);
      if (port_ref_node) {
        port_id_node = GetIdentifierFromPortReference(*port_ref_node);
      }
    }
    if (!port_id_node) {
      LOG(WARNING) << "Unhandled type of port declaration or port declaration "
                      "with no identifier. Ignoring";
      continue;
    }

    const TokenInfo &port_id_token = port_id_node->get();
    const LineColumn port_linecol =
        text_structure_.GetRangeForToken(port_id_token).start;
    if (port_linecol.line < linecol.line ||
        (port_linecol.line == linecol.line &&
         port_linecol.column < linecol.column)) {
      ports_before.insert(port_id_token.text());
    }
  }
  return ports_before;
}

absl::flat_hash_set<absl::string_view> AutoExpander::GetPortsConnectedBefore(
    const Symbol &instance, const LineColumn linecol) const {
  absl::flat_hash_set<absl::string_view> ports_before;
  for (const auto &port : FindAllActualNamedPort(instance)) {
    const SyntaxTreeLeaf *const id_node = GetActualNamedPortName(*port.match);
    if (!id_node) {
      LOG(WARNING) << "Named port connection with no identifier? Ignoring";
      continue;
    }
    const TokenInfo &id_token = id_node->get();
    const LineColumn port_linecol =
        text_structure_.GetRangeForToken(id_token).start;
    if (port_linecol.line < linecol.line ||
        (port_linecol.line == linecol.line &&
         port_linecol.column < linecol.column)) {
      ports_before.insert(id_token.text());
    }
  }
  return ports_before;
}

std::optional<TextEdit> AutoExpander::ExpandAutoarg(
    const Module &module) const {
  const SyntaxTreeNode *const port_parens =
      GetModulePortParenGroup(module.Symbol());
  if (!port_parens) return {};  // No port paren group, so no AUTOARG
  const absl::string_view port_paren_span = StringSpanOfSymbol(*port_parens);

  std::cmatch match;
  if (!std::regex_search(port_paren_span.begin(), port_paren_span.end(), match,
                         autoarg_re_)) {
    return {};
  }
  const absl::string_view comment_span(
      port_paren_span.begin() + match.position(),
      static_cast<size_t>(match.length()));
  const LineColumn start_linecol =
      text_structure_.GetRangeForText(comment_span).start;

  // Ports listed before the comment should not be redeclared
  const auto predeclared_ports =
      GetPortsListedBefore(module.Symbol(), start_linecol);

  std::ostringstream new_text;
  module.EmitNonAnsiPortList(
      new_text, indent_, "Inputs", [&](const Port &port) {
        return port.direction == Port::Direction::kInput &&
               !predeclared_ports.contains(port.name);
      });
  module.EmitNonAnsiPortList(
      new_text, indent_, "Inouts", [&](const Port &port) {
        return port.direction == Port::Direction::kInout &&
               !predeclared_ports.contains(port.name);
      });
  module.EmitNonAnsiPortList(
      new_text, indent_, "Outputs", [&](const Port &port) {
        return port.direction == Port::Direction::kOutput &&
               !predeclared_ports.contains(port.name);
      });
  if (new_text.tellp() != 0) {
    new_text << '\n' << indent_;
  }

  const LineColumn end_linecol =
      text_structure_.GetRangeForText(port_paren_span).end;
  return TextEdit{.range =
                      {
                          .start = {.line = start_linecol.line,
                                    .character = start_linecol.column},
                          .end = {.line = end_linecol.line,
                                  .character = end_linecol.column - 1},
                      },
                  .newText = absl::StrCat(comment_span, new_text.str())};
}

std::optional<TextEdit> AutoExpander::ExpandAutoinst(Module *module,
                                                     const Symbol &instance,
                                                     absl::string_view type_id,
                                                     const Template *tmpl) {
  auto parens = GetParenGroupFromModuleInstantiation(instance);
  const absl::string_view paren_span = StringSpanOfSymbol(*parens);

  std::cmatch match;
  if (!std::regex_search(paren_span.begin(), paren_span.end(), match,
                         autoinst_re_)) {
    return {};
  }
  const absl::string_view comment_span(paren_span.begin() + match.position(),
                                       static_cast<size_t>(match.length()));
  const LineColumn start_linecol =
      text_structure_.GetRangeForText(comment_span).start;

  const Symbol *const type_def =
      symbol_table_handler->FindDefinitionSymbol(type_id);
  if (!type_def) {
    LOG(ERROR) << "AUTOINST: No definition found for module type: " << type_id;
    return {};
  }
  if (!modules_.contains(type_id)) {
    modules_.insert(std::make_pair(type_id, Module(*type_def)));
  }
  const Module &inst_module = modules_.at(type_id);

  // Ports connected before the AUTOINST comment should be ignored
  const auto preconnected_ports =
      GetPortsConnectedBefore(instance, start_linecol);

  std::ostringstream new_text;
  const std::string conn_indent = absl::StrCat(indent_, indent_);
  inst_module.EmitPortConnections(
      new_text, conn_indent, "Inputs",
      [&](const Port &port) {
        return port.direction == Port::Direction::kInput &&
               port.declaration != Port::Declaration::kUndeclared &&
               !preconnected_ports.contains(port.name);
      },
      tmpl);
  inst_module.EmitPortConnections(
      new_text, conn_indent, "Inouts",
      [&](const Port &port) {
        return port.direction == Port::Direction::kInout &&
               port.declaration != Port::Declaration::kUndeclared &&
               !preconnected_ports.contains(port.name);
      },
      tmpl);
  inst_module.EmitPortConnections(
      new_text, conn_indent, "Outputs",
      [&](const Port &port) {
        return port.direction == Port::Direction::kOutput &&
               port.declaration != Port::Declaration::kUndeclared &&
               !preconnected_ports.contains(port.name);
      },
      tmpl);

  // The module's port connections need to be updated, as new ones may have
  // been generated
  const absl::string_view instance_name =
      GetModuleInstanceNameTokenInfoFromGateInstance(instance)->text();
  inst_module.GenerateConnections(tmpl, [&](const Port &port,
                                            const Connection &connected) {
    if (port.declaration == Port::Declaration::kUndeclared) return;
    ConnectedInstance connection{.instance = instance_name, .type = type_id};
    module->AddGeneratedConnection(connected.port_name, port.direction,
                                   connection, port.packed_dimensions,
                                   port.unpacked_dimensions);
  });

  const LineColumn end_linecol =
      text_structure_.GetRangeForText(paren_span).end;
  return TextEdit{.range =
                      {
                          .start = {.line = start_linecol.line,
                                    .character = start_linecol.column},
                          .end = {.line = end_linecol.line,
                                  .character = end_linecol.column - 1},
                      },
                  .newText = absl::StrCat(comment_span, new_text.str())};
}

// Get the string span of the regex match in the context of the given symbol
absl::string_view GetStringSpanOfMatchInSymbol(const Symbol &symbol,
                                               const std::cmatch &match) {
  const absl::string_view module_span = StringSpanOfSymbol(symbol);
  return {module_span.begin() + match.position(),
          static_cast<size_t>(match.length())};
}

// Checks if the given span overlaps with the span of the module's port parens
// group
bool IsStringSpanOfMatchInModuleHeader(const Symbol &module,
                                       const std::cmatch &match) {
  const absl::string_view auto_span =
      GetStringSpanOfMatchInSymbol(module, match);
  const verible::SyntaxTreeNode *const port_parens =
      GetModulePortParenGroup(module);
  return port_parens &&
         SpansOverlapping(auto_span, StringSpanOfSymbol(*port_parens));
}

std::optional<TextEdit> AutoExpander::ExpandAutoDeclarations(
    const Module &module, const std::cmatch &match,
    const absl::string_view indent, const absl::string_view description,
    const std::function<void(const Module &, std::ostream &)> &emit) const {
  const absl::string_view auto_span =
      GetStringSpanOfMatchInSymbol(module.Symbol(), match);
  const LineColumnRange range = text_structure_.GetRangeForText(auto_span);
  std::stringstream new_text;
  new_text << match.str(1);  // Matched AUTO comment
  new_text << indent << "// Beginning of automatic " << description << '\n';
  const auto length_before_emit = new_text.tellp();
  emit(module, new_text);
  if (length_before_emit == new_text.tellp()) return {};
  new_text << indent << "// End of automatics" << '\n';
  return TextEdit{
      .range =
          {
              .start = {.line = range.start.line,
                        .character = range.start.column},
              .end = {.line = range.end.line, .character = range.end.column},
          },
      .newText = new_text.str()};
}

std::optional<TextEdit> AutoExpander::ExpandAutoPorts(
    Module *module, const std::optional<std::cmatch> &match,
    const Port::Direction direction) const {
  if (!match) return {};
  auto end = StringSpanOfSymbol(module->Symbol()).end();
  const verible::SyntaxTreeNode *const port_parens =
      GetModulePortParenGroup(module->Symbol());
  if (port_parens) end = StringSpanOfSymbol(*port_parens).end();
  const size_t end_offset = static_cast<size_t>(
      std::distance(StringSpanOfSymbol(module->Symbol()).begin(), end));
  const bool last = !module->AnyPorts([match, end_offset](const Port &port) {
    return port.offset > static_cast<size_t>(match->position()) &&
           port.offset < end_offset;
  });
  const PortDeclStyle style =
      IsStringSpanOfMatchInModuleHeader(module->Symbol(), *match)
          ? last ? PortDeclStyle::kCommaSeparatorExceptLast
                 : PortDeclStyle::kCommaSeparator
          : PortDeclStyle::kColonSeparator;
  const absl::string_view description = direction == Port::Direction::kInput
                                            ? "inputs (from autoinst inputs)"
                                        : direction == Port::Direction::kInout
                                            ? "inouts (from autoinst inouts)"
                                            : "outputs (from autoinst outputs)";
  auto result = ExpandAutoDeclarations(
      *module, *match, indent_, description,
      [this, direction, style](const Module &module, std::ostream &output) {
        module.EmitPortDeclarations(
            output, indent_, style, [direction](const Port &port) {
              return port.declaration == Port::Declaration::kUndeclared &&
                     port.direction == direction;
            });
      });
  module->MarkUndeclaredPortsAsAutogenerated(direction);
  return result;
}

// Do a regex search in the span of the given symbol
std::optional<std::cmatch> SearchInSymbol(const Symbol &symbol,
                                          const std::regex &re) {
  const absl::string_view module_span = StringSpanOfSymbol(symbol);
  std::cmatch match;
  if (std::regex_search(module_span.begin(), module_span.end(), match, re)) {
    return match;
  }
  return {};
}

std::optional<TextEdit> AutoExpander::ExpandAutowire(
    const Module &module) const {
  const auto match = SearchInSymbol(module.Symbol(), autowire_re_);
  if (!match || IsStringSpanOfMatchInModuleHeader(module.Symbol(), *match)) {
    return {};
  }
  const absl::string_view auto_span =
      GetStringSpanOfMatchInSymbol(module.Symbol(), *match);
  return ExpandAutoDeclarations(
      module, *match, indent_,
      "wires (for undeclared instantiated-module outputs)",
      [this, auto_span](const Module &module, std::ostream &output) {
        module.EmitUndeclaredOutputWireDeclarations(output, indent_, auto_span);
      });
}

std::optional<TextEdit> AutoExpander::ExpandAutoreg(
    const Module &module) const {
  const auto match = SearchInSymbol(module.Symbol(), autoreg_re_);
  if (!match || IsStringSpanOfMatchInModuleHeader(module.Symbol(), *match)) {
    return {};
  }
  const absl::string_view auto_span =
      GetStringSpanOfMatchInSymbol(module.Symbol(), *match);
  return ExpandAutoDeclarations(
      module, *match, indent_, "regs (for this module's undeclared outputs)",
      [this, auto_span](const Module &module, std::ostream &output) {
        module.EmitUnconnectedOutputRegDeclarations(output, indent_, auto_span);
      });
}

//
std::optional<std::cmatch> FindMatchAndErasePortsInRange(
    AutoExpander::Module *module, const std::regex &re) {
  auto match = SearchInSymbol(module->Symbol(), re);
  if (match) {
    module->ErasePortsInRange(match->position(), match->length());
  }
  return match;
}

//
void SetUndeclaredPortOffsets(AutoExpander::Module *module,
                              AutoExpander::Port::Direction direction,
                              const std::optional<std::cmatch> &match) {
  if (match) {
    module->SetUndeclaredPortOffsets(direction, match->position());
  }
}

std::vector<TextEdit> AutoExpander::Expand() {
  std::vector<TextEdit> edits;
  if (!text_structure_.SyntaxTree()) {
    LOG(ERROR)
        << "Cannot perform AUTO expansion: failed to retrieve a syntax tree";
    return {};
  }
  std::vector<Module *> buffer_modules;  // Ordered list of all modules
                                         // in the buffer being modified
  for (const auto &mod_decl :
       FindAllModuleDeclarations(*text_structure_.SyntaxTree())) {
    Module module(*mod_decl.match);
    buffer_modules.push_back(
        &modules_.insert(std::make_pair(module.Name(), std::move(module)))
             .first->second);
  }
  for (auto module : buffer_modules) {
    module->RetrieveDependencies(modules_);
  }
  // Sort modules in the buffer based on a dependency graph, so that AUTOs are
  // expanded in order
  std::sort(buffer_modules.begin(), buffer_modules.end(),
            [](const Module *left, const Module *right) {
              return right->DependsOn(left);
            });
  for (Module *const module : buffer_modules) {
    // Ports declared in AUTOINPUT/AUTOINOUT/AUTOOUTPUT must be removed from
    // the module, as they should be regenerated every time (in case they get
    // removed or their names change)
    const auto autoinput_match =
        FindMatchAndErasePortsInRange(module, autoinput_re_);
    const auto autoinout_match =
        FindMatchAndErasePortsInRange(module, autoinout_re_);
    const auto autooutput_match =
        FindMatchAndErasePortsInRange(module, autooutput_re_);
    // Do AUTOINST expansion
    module->RetrieveAutoTemplates();
    for (const auto &data : FindAllDataDeclarations(module->Symbol())) {
      const Symbol *const type_id_node =
          GetTypeIdentifierFromDataDeclaration(*data.match);
      // Some data declarations do not have a type id, ignore those
      if (!type_id_node) continue;
      const absl::string_view type_id = StringSpanOfSymbol(*type_id_node);
      // Find an AUTO_TEMPLATE that matches this instance
      int64_t instance_offset = std::distance(
          StringSpanOfSymbol(module->Symbol()).begin(), type_id.begin());
      const Template *tmpl = module->GetAutoTemplate(type_id, instance_offset);
      for (const auto &instance : FindAllGateInstances(*data.match)) {
        if (const auto edit =
                ExpandAutoinst(module, *instance.match, type_id, tmpl)) {
          edits.push_back(*edit);
        }
      }
    }
    // Expand AUTO port declarations
    SetUndeclaredPortOffsets(module, Port::Direction::kInput, autoinput_match);
    SetUndeclaredPortOffsets(module, Port::Direction::kInout, autoinout_match);
    SetUndeclaredPortOffsets(module, Port::Direction::kOutput,
                             autooutput_match);
    if (const auto edit =
            ExpandAutoPorts(module, autoinput_match, Port::Direction::kInput)) {
      edits.push_back(*edit);
    }
    if (const auto edit =
            ExpandAutoPorts(module, autoinout_match, Port::Direction::kInout)) {
      edits.push_back(*edit);
    }
    if (const auto edit = ExpandAutoPorts(module, autooutput_match,
                                          Port::Direction::kOutput)) {
      edits.push_back(*edit);
    }
    // Expand AUTO wire/reg declarations
    if (const auto edit = ExpandAutowire(*module)) {
      edits.push_back(*edit);
    }
    if (const auto edit = ExpandAutoreg(*module)) {
      edits.push_back(*edit);
    }
    module->SortPortsByOffset();  // Ports need to be sorted by offset to
                                  // ensure AUTOARG stability
    // AUTOARG
    if (const auto edit = ExpandAutoarg(*module)) {
      edits.push_back(*edit);
    }
  }
  return edits;
}

}  // namespace

std::vector<TextEdit> GenerateAutoExpandTextEdits(
    SymbolTableHandler *symbol_table_handler,
    const BufferTracker *const tracker) {
  if (!tracker) return {};
  const ParsedBuffer *const current = tracker->current();
  if (!current) return {};  // Can only expand if we have latest version
  AutoExpander expander(current->parser().Data(), symbol_table_handler);
  return expander.Expand();
}

std::vector<CodeAction> GenerateAutoExpandCodeActions(
    SymbolTableHandler *symbol_table_handler,
    const BufferTracker *const tracker, const CodeActionParams &p) {
  auto edits = GenerateAutoExpandTextEdits(symbol_table_handler, tracker);
  if (edits.empty()) return {};
  std::vector<CodeAction> result;
  // Make a code action for expanding all AUTOs in the current buffer
  result.emplace_back(CodeAction{
      .title = "Expand all AUTOs in file",
      .kind = "refactor.rewrite",
      .diagnostics = {},
      .isPreferred = false,
      .edit = {.changes = {{p.textDocument.uri, edits}}},
  });
  // Remove edits outside of the code action range
  const auto it =
      std::remove_if(edits.begin(), edits.end(), [&](TextEdit &edit) {
        return p.range.end.line < edit.range.start.line ||
               p.range.start.line > edit.range.end.line;
      });
  edits.erase(it, edits.end());
  // If no remaining edits, just return the global action
  if (edits.empty()) return result;
  // Else make a local code action as well
  result.emplace_back(CodeAction{
      .title = edits.size() > 1 ? "Expand all AUTOs in selected range"
                                : "Expand this AUTO",
      .kind = "refactor.rewrite",
      .diagnostics = {},
      .isPreferred = false,
      .edit = {.changes = {{p.textDocument.uri, edits}}},
  });
  return result;
}

}  // namespace verilog
